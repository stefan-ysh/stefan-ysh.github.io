---
title: HashMap源码分析
date: 2021-12-12 13:25:09
permalink: /pages/e5bd2a/
categories:
  - 技术文章
  - Java
  - 集合
  - HashMap
---
##  1. put()
### 注释

首先看方法注释。需要注意的是，待put的键已经存在映射时，会覆盖旧值，并返回旧值。这点之后再拓展说明。
![在这里插入图片描述](https://cdn.jsdelivr.net/gh/Wu-Corey/image_store/202112121325793.png)

```java
	public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```
### hash()
```java
	static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
这里获取哈希值采用的是用hashCode与自身无符号右移的结果，进行异或运算得到。为什么要这么做而不直接使用hashCode呢？
(1) hashCode是整数，大小在-2147483648到2147483648之间。而数组大小却一般较小。所以要对hashCode进行散列，映射获得较小范围的数。一般可以采用对数组长度 n 取模，取模的结果在0到n-1之间，恰好对应数组索引范围。
(2) 但我们看看下文putVal()方法中，HashMap每次put值的时候，似乎是用  (n-1) & hash 来获取数组索引的。实际上，这个操作就相当于取模，即 h % n.
解析：
在HashMap中，数组长度n必须取 2的m次幂。这里我们取 m = 2，即数组长度为4来探究：
```java
1  --------------->  0 0 0 1
2  --------------->  0 0 1 0
3  --------------->  0 0 1 1
4  --------------->  0 1 0 0
5  --------------->  0 1 0 1
6  --------------->  0 1 1 0
7  --------------->  0 1 1 1
8  --------------->  1 0 0 0
```
取模运算：
```java
1 % 4 = 1			   	 0 1
2 % 4 = 2			     1 0
3 % 4 = 3			     1 1
4 % 4 = 0			     0 0
5 % 4 = 1			     0 1
6 % 4 = 2			     1 0
7 % 4 = 3			     1 1
8 % 4 = 0			     0 0
```
**对于n取值为2的m次幂来说，k % n，实际上就是对k进行低位截断，取k的后m位**，那么如何来截断呢？

```java
2的m次幂，形如(1 0 0 0 ... 0)即1后面m个零
n -1 的二进制形如 (1 1 1 ...1) 即m个1
与运算(&)的规则：同1得1，其余得0
易见，这里与运算的结果就是是k的最低2位
```
故对于一个2的整数次幂n，有： k % n <==>   k & (n -1)
延伸思考
在十进制中取模，如 123 % 100 = 23，其实也是对123进行从低位截断，100是10的2次幂，所以截断后两位获得23。假如除数不是进制的幂次，那么该方法失效。
在二进制中也是如此，稍加举例验证如

```java
7 % 3 = 1
7 & (3-1) = 0111 & 0010 = 2
```
可以看出，除数不是2的n次幂，就不能使用与运算代替取模运算。
以上也能解释，为什么**HashMap数组长度要求必须是2的n次幂**


(3)《算法导论》中提到，对除法散列法 h(k)=k % m：“一个不太接近2的整数次幂的素数常常是m的较好选择”。其原因就在于，如果除数为2的整数次幂，那么每次散列，结果只与k的低几位有关，这会导致散列地不够均匀。
那么HashMap为什么偏偏要采用2的整数次幂来作为除数呢？

明确一点。HashMap作为存储临时数据的结构，数据量不会太大，n 一般不会大于2的16次方(即n <= 65536)，所以散列结果只取决于hash的低16位，高16位并没有参与计算，如果直接用hashCode，会导致散列得不够均匀，哈希碰撞概率高。

故HashMap并没有采用直接对hashCode进行散列，而是先对它进行了处理:

```java
	h = key.hashCode():		1101 1010 1111 0101 0001 0101 1110 1010
	h >>> 16:				0000 0000 0000 0000 1101 1010 1111 0101
	k = h ^ (h >>> 16):		1101 1010 1111 0101 1100 1111 0001 1111
```
可以看出，把hashCode与自身无符号右移16位的结果进行异或，可以使结果k的低16位同时具有原来高16位与原来低16位的信息，这样，k的低16位就更加随机，进行取模散列取低16位的结果也就更加均匀。
(4) 至于为什么高16位、低16位间混合的过程采用的是异或运算(^)而不是与运算(&)也不是或运算(|)呢？

```java
与运算
&	1	0
1	1	0
0	0	0
结果：P(1) = 1/4;P(0) = 3/4

或运算
|	1	0
1	1	1
0	1	0
结果：P(1) = 3/4;P(0) = 1/4

异或运算
^	1	0
1	0	1
0	1	0
结果：P(1) = 1/2;P(0) = 1/2
```
由上可知：无论与运算还是或运算，得到0、1的概率都不相等，都会使结果更加偏向1或者0，使高16位低16位间运算结果不够均匀，无法满足要求。

### putVal()

```java
	/**
	 * @param hash         处理过的哈希值
	 * @param key          键
	 * @param value        值
	 * @param onlyIfAbsent 如果为true，则不会对已存在的key修改值
	 * @param evict        LinekdHashMap尾操作使用
	 * @return 该key的旧值；如果没有，则为null
	 */
	final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
		Node<K, V>[] tab;
		Node<K, V> p;
		int n, i;
		/********初始化********/
		// 数组tab为空 第一次扩容 即初始化tab
		if ((tab = table) == null || (n = tab.length) == 0)
			n = (tab = resize()).length;
		/********添加/修改操作********/
		if ((p = tab[i = (n - 1) & hash]) == null)
			// (n - 1) & hash 获取key在数组中的索引(找到自己要进的桶)
			// 如果该索引对应的值为空(空桶) 则以k,v构造一个链表节点 放在数组该位置 完成添加
			tab[i] = newNode(hash, key, value, null);
		else {
			// 非空桶 在已有链表/树上添加节点
			Node<K, V> e;
			K k;
			if (p.hash == hash 	// 如果哈希值与当前头结点相同
					&& // 当前头结点key 与 要放的key：(1)要么是同一对象(2)要么equals计算后相等 
					((k = p.key) == key || (key != null && key.equals(k))))
				// 则替换当前头结点节点值
				e = p;
			else if (p instanceof TreeNode)
				// 处理红黑树节点
				e = ((TreeNode<K, V>) p).putTreeVal(this, tab, hash, key, value);
			else {
				// 遍历链表 处理链表节点
				for (int binCount = 0;; ++binCount) {
					if ((e = p.next) == null) {
						// 当前节点为尾结点 新增节点放在尾节点后
						p.next = newNode(hash, key, value, null);
						if (binCount >= TREEIFY_THRESHOLD - 1)
							// 节点数大于等于8 尝试转化为红黑树(数组长度小于64会扩容，而不是树化)
							treeifyBin(tab, hash);
						break;
					}
					if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
						break;
					p = e;
				}
			}
			if (e != null) { // existing mapping for key
				V oldValue = e.value;
				// 判断是否允许覆盖
				if (!onlyIfAbsent || oldValue == null)
					e.value = value;
				// 空方法 LinkedHashMap会实现它做后置操作
				afterNodeAccess(e);
				// 返回旧值
				return oldValue;
			}
		}
		/********修改/添加完成之后操作********/
		// 修改次数+1
		++modCount;
		// 如果当前size > 阈值(容量*负载因子) 则扩容
		if (++size > threshold)
			resize();
		afterNodeInsertion(evict);
		// 添加操作成功 返回null
		return null;
	}
```

###  resize()
```java
    final HashMap.Node<K,V>[] resize() {
        HashMap.Node<K,V>[] oldTab = table;
        int oldCap = (oldTab == null) ? 0 : oldTab.length;
        int oldThr = threshold;
        int newCap, newThr = 0;
        if (oldCap > 0) {
            if (oldCap >= MAXIMUM_CAPACITY) {
                threshold = Integer.MAX_VALUE;
                return oldTab;
            }
            // ***扩容***
            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY // 新容量 = 旧容量 * 2
                    &&
                    oldCap >= DEFAULT_INITIAL_CAPACITY)
                // 新阈值 = 旧阈值 * 2
                newThr = oldThr << 1;
        }
        else if (oldThr > 0) // initial capacity was placed in threshold
            newCap = oldThr;
        else {
            // ***初始化***
            // 初始容量 16
            newCap = DEFAULT_INITIAL_CAPACITY;
            // 初始阈值 0.75 * 16 = 12
            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
        }
        if (newThr == 0) {
            float ft = (float)newCap * loadFactor;
            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                    (int)ft : Integer.MAX_VALUE);
        }
        threshold = newThr;
        // 以新容量初始化一个新数组
        HashMap.Node<K,V>[] newTab = (HashMap.Node<K,V>[])new HashMap.Node[newCap];
        table = newTab;
        // ***重新分配元素***
        if (oldTab != null) {
            for (int j = 0; j < oldCap; ++j) {
                HashMap.Node<K,V> e;
                if ((e = oldTab[j]) != null) {
                    oldTab[j] = null;
                    if (e.next == null)
                        newTab[e.hash & (newCap - 1)] = e;
                    else if (e instanceof HashMap.TreeNode)
                        ((HashMap.TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                    else {
                        HashMap.Node<K,V> loHead = null, loTail = null;
                        HashMap.Node<K,V> hiHead = null, hiTail = null;
                        HashMap.Node<K,V> next;
                        do {
                            // 当前节点
                            next = e.next;
                            // 重新分配元素的核心！！！
                            if ((e.hash & oldCap) == 0) {
                                if (loTail == null)
                                    loHead = e;
                                else
                                    loTail.next = e;
                                loTail = e;
                            }
                            else {
                                if (hiTail == null)
                                    hiHead = e;
                                else
                                    hiTail.next = e;
                                hiTail = e;
                            }
                        } while ((e = next) != null);
                        if (loTail != null) {
                            // loHead -> loHead 链表挂在原数组索引位置
                            loTail.next = null;
                            newTab[j] = loHead;
                        }
                        if (hiTail != null) {
                            // hiHead -> hiTail 链表挂在[原数组索引+oldCap]的位置
                            hiTail.next = null;
                            newTab[j + oldCap] = hiHead;
                        }
                    }
                }
            }
        }
        return newTab;
    }
```

 - 数组为空 则根据默认初始容量(16)初始化；数组非空，则扩容为旧容量的两倍。把元素分配到新的哈希桶中
 - 这里我们重点关注重新分配元素的核心操作：e.hash & oldCap 

```java
以odlCap = 16 为例 hash1 = 1  hash2 = 17
扩容前，hash1、hash2对应的节点都在tab[1]位置。下面进行与操作
1				0000 0001
&
16				0001 0000
结果：			0000 0000	为0

17				0001 0001
&
16				0001 0000
结果：			0001 0000	不为0	
```
我们可以看到，对于2的4次幂，低4位全是0，所以与运算的结果只与右数第5位有关，且hash的右数第5位为1则结果为1，为0则结果为0。所以这个与运算实际上是在判断hash的右数第5位是否为1。

判断右数第5位的目的在于：hash对旧容量16取模的结果是它的低4位，当容量变为32，那么就是取hash的低5位。如果hash的右数第5位为0，则取模结果不变，索引不用改变，如果是1，则取模结果只需要加上旧容量的大小16，即索引变为原来索引+旧容量大小。